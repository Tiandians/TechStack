# 计算机科学导论

## 书本信息

第四版

## 章节目录

* 第1章 绪论
  * [[计算机模型]]
* 第2章 [[数字系统]]
* 第3章 [[数据存储]]
* 第4章 [[数据运算]]
* 第5章 计算机组成
* 第6章 计算机网络和因特网
* 第7章 操作系统
* 第8章 算法
* 第9章 程序设计语言
* 第10章 软件工程
* 第11章 数据结构
* 第12章 抽象数据类型
* 第13章 文件结构
  * [[文件系统]]
* 第14章 数据库
* 第15章 数据压缩
* 第16章 安全
* 第17章 计算理论
* 第18章 人工智能
* 第19章 社交媒体导论
* 第20章 社会和道德问题
* 附录A [[Unicode]]
* 附录B [[UML]]
* 附录C 伪代码
* 附录D 结构图
* 附录E [[布尔代数]]和[[逻辑电路]]
* 附录F C、C++ 和 Java 程序示例
* 附录G 数学知识
* 附录H 错误检测和纠正
* 附录I 符号加绝对值整数的加减法
* 附录J 实数的加减法


# 计算机科学导论 摘要

全书大纲：
* 数据的表示与运算
* 计算机硬件
* 计算机软件
* 数据组织与抽象
* 高级话题

## Ch1. 绪论

关键词：图灵模型，冯诺依曼模型，计算机三大部分，简明历史

* 可编程数据处理器的模型
* 程序是什么？
* 冯诺依曼模型的三个要点
* 计算机组成部分
* 计算机简明历史

## Ch.2 数字系统

> CSAPP：建议你反复阅读数学原理描述和示例与讨论，直到你对该属性的说明内容及其重要性有了**牢固的直觉**。对于更加复杂的属性，你应该尝`````试推导。

关键词：位置化数字系统

* 位置化数字系统的数学表示
* 数字系统的两个要素：符号集、底（基数）
* 描述二进制、八进制、十进制、十六进制数字系统
* 十进制到其他进制的转换方法：整数（连除取余数）和小数（连乘取整数）
* **数码的数量**：$\log_b N$的高限，源系统数码最大数量$k(b_1^k)$和目标系统数码最小数量$x(b_2^x)$的关系
$$x\geq k \times \log_{b_2}b_1$$
* 其他进制到十进制的转换

> CSAPP：编写机器级程序的常见任务就是在位模式的各进制中进行人工转换
>
> 如何快速将2的幂$2^k$转换为十六进制数？
>
> * 定义：位向量$\hat{x} = [x_{\omega-1}\dots x_{0}]$
>
> * 练习：给出无符号整数的函数表达式。这些函数是怎样的映射？

## Ch.3 数据储存

> CSAPP：大多数计算机中，8位的字节（byte）是最小的可寻址的内存单位。每个字节以一个唯一的数字标识，它们的集合就是**虚拟地址空间virtual address space**
>
> 每台计算机都有一个**字长**，用于标称指针数据的大小。对于字长为$\omega$的机器来说，虚拟地址的范围为$0\sim 2^{\omega}-1$

关键词：数据类型，整数储存，浮点数储存，文本，音频，图像，视频

* 什么是多媒体？
* 位模式

### 存储数字

整数的储存：定点表示法。简述以下各表示方法的**数据范围，存储、译解步骤，溢出情况和应用**

* 无符号表示法：$0\sim 2^k-1$ 

  * 计数、寻址、存储其他数据类型

* 符号加绝对值表示法：**两个0** $-2^{k-1}-1 \sim 2^{k-1}-1$ 

  * 溢出情况：改变符号，绝对值归零并同向变化
  * 模拟采样信号

* 二进制补码表示法：$-2^{k-1} \sim 2^{k-1}-1$ 

  * 理解为将无符号整数的有效范围划分为两个相等的子范围，左侧表示非负整数，右侧表示负整数。然后按照左负右正的常规互相交换。
  * 存储步骤：先转二进制，负数取补码储存
  * 译解步骤：最左位为1取补码，否则不操作 

  * 溢出情况：改变符号，绝对值反向变化 存储整数的标准，运算简便

  * 反码运算
  * 补码运算**Two's completement**
  * 另一种补码：反码再+1

> CSAPP：理解补码表示的方法：把最高位看作权重为$-2^{w-1}$的位
>
> 尝试给出反码运算的数学表达式，并理解反码的表达式是如何构建的？
>
> 注意**反码操作**和**整数的反码表示**。反码表示的整数中，只有负数才进行反码操作。

实数的储存：浮点表示法（具有**很大整数部分或很小小数部分的数**）：符号、位移量和定点数


* 规范化：定点数小数点左侧只有一个非零数码。二进制数规范化后，左侧的1隐含了。
* 十进制称为科学计数法，二进制称为浮点表示法
* 尾数：小数点右边的二进制数定义了该数的精度，作为**无符号整数存储**
* 指数：有符号，使用**余码系统**：偏移量$(2^{m-1}-1)$被加到每个数字中（m为内存单元大小），统一移到非负的一遍。如4位存储单元使用余7码系统。这样做的优势是对这些整数进行比较或运算时不需要考虑符号。
* IEEE标准：单进度为1，8，23；双精度为1，11，52
* 储存：确定符号，转二进制，规范化，储存指数和尾数，连接三个部分
* 还原：拆分为三个部分，确定符号，解码位移量，去规范化尾数，还原数字，转十进制，加上符号
* **浮点数的上溢和下溢**：举例单精度浮点数最大负值为$-(1-2^{-24})\times 2^{+128}$，其中，尾数23位无符号数，最大绝对值为$2^{24}-1$，指数8位余码数，最大为$2^{8-1}=128$。最小负值为$-(1-2^{-1})\times 2^{-127}$
* 零的约定：三个部分都设置为0
* 什么是**截断错误**？

### 存储文本

> 补充知识：ASCII和Unicode
>
> | 编码类型  | 位数 |
> | --------- | ---- |
> | ASCII     | 7    |
> | 扩展ASCII | 8    |
> | Unicode   | 32   |
>
> #### UNICODE的编码结构
>
> 每个Unicode编码以十六进制表示为 **U-XXXXXXXX** 
>
> * 前16位定义平面
> * 后16位定义字符
> * ASCII占据Unicode中前128个编码，即U-00000000 ~ U-0000007F
>
> ASCII表的记忆
>
> | 关键字符 | 十进制   | 十六进制 |
> | -------- | -------- | -------- |
> | 空字符   | 0        | 00       |
> | 空格     | 32       | 20       |
> | 0        | ***48*** | 30       |
> | 9        | 57       | 39       |
> | A        | ***65*** | 41       |
> | Z        | 90       | 5A       |
> | a        | ***97*** | 61       |
> | z        | 122      | 7A       |
> | 删除     | 127      | 7F       |

### 存储音频

文本是**数字**数据的例子，音频是**模拟**数据的例子。

* 采样
* 采样率
* 量化：截取为最近整数值
* 编码
  * 位深度：每样本位的位数
  * 位率：每秒音频位数（位率）=深度x每秒样本数 $ R = B \times S$
* 声音编码标准：MP3（MPEG Layer3），S=44100，B=16，R=705600b/s，再去掉人耳无法识别的信息进行压缩

### 存储图像

光栅图或矢量图

#### 光栅图

* 采样称为**扫描**，样本称为像素
* 解析度：扫描率，每英寸的方块记录多少像素。
* 色彩深度：
  * 真彩色：24位，每个三原色RGB表示为8位，每种色彩都由0~255之间表示
  * 索引色：许多应用程序并不需要如此大的色彩范围，索引色仅使用其中的一部分，对其建立索引
* 图像编码标准：
  * JPEG使用真色彩，但压缩图像减少位的数量
  * GIF使用索引色模式


#### 矢量图

由定义如何绘制形状的一系列命令构成。要显示图像时，系统依据图像的尺寸大小用相同的公式绘制图形。

TrueType，PostScript和CAD（计算机辅助设计）主要使用矢量图

### 存储视频

视频是随空间（单个图像）和时间（一系列图像）变化的信息表现



## Ch4. 数据运算

关键词：算术运算、移位运算、逻辑运算

### 逻辑运算
位层次和模式层次上的逻辑运算



* 非、与、或和异或
* 思考：如何用其他运算符模拟异或？异或的特性
* 位模式的四种应用：求反、使指定的位复位（置0）、对指定的位置位（置1）、使指定的位反转
* **掩码**

### 移位（Shift）运算

* 逻辑移位运算
  * 不带符号位的数：这些移位运算可能改变数的符号
  * 填0或循环移位（旋转运算）
* 算数移位运算
  * 假定位模式是使用**二进制补码**存储的带符号整数。
  * 算数右移对整数除二，算数左移对整数乘二，这些运算本不应该改变符号位
  * 算数右移：保留符号位，并复制入右侧位中，因此保存符号
  * 算数左移：丢弃符号位，接受左边为符号位。如果新符号位与原先相同，运算**成功**，否则发生溢出

### 算术运算

#### 二进制补码中的加减法

* 遇到减法时，转变为加法，只需为第二个数求二进制的补
* 加法正常

> ### [深入理解原码，反码，补码的原理 ](https://www.cnblogs.com/zhxmdefj/p/10902322.html)
>
> 花了很长时间理解补码的构造意图。自己理了一遍逻辑如下：
>
> * 计算机只能进行加法，不能进行减法
> * 由于位数的限制，加法相当于在模运算下进行
> * 模运算下的加法可以看作一个闭环
>
> 由上面三条说明，我们的目标是：在模运算的闭环中用加法模拟减法
>
> * 数学定义：
>   * 对于长度为 $\omega$ 的位向量，它的模为 $2^{\omega}$  ，这一位向量在长度 $0\sim 2^{\omega}-1$ 的环内
> * 要用加法模拟减法 $a - b = c$ ，目的是找到 $d$ 使得 $ (a + d)mod 2^\omega = c$
> * 画出这样一个环，很容易看出加到 $c$ 和减到 $c$ 合起来绕了一个圈，因此： $d = 2^\omega - b$
> * 通过这一等式可以建立从负数 $-b$ 到 $x_d$ 的映射，这个映射把负整数 $b$ 映射为 $d = 2^\omega - b$ 的位模式， $d$ 的位模式就是 $-b$ 的补码表示
> * 这样的映射就是补码操作：先取反码再+1
>
> 接下来再分析以上过程，以0110 - 0010 = 0100 即6-2=4为例
>
> * $x$ 是一个负数
>
> * 找到 $d=10000-0010=1110$。我们发现：**$d$ 可以通过取反码再+1的找到**。
>
>   原理：$${|x|}_反+|x| = 2^\omega-1$$
>
> * $0110 + 1110 = 10100$ 取模后即为 $0100$
>
>   原理：负数的补码和它的绝对值相加等于模（本质是闭环内绕一圈的两种方法）
>
>   $$2^\omega = x_补 + |x| $$
>
>   * 由以上两式，我们得到了反码和补码的关系：$x_补={|x|}_反+1$
>
> * 要把 $1110$ 映射为 $-2$ ，就需要把最左侧的权重设置为 $-8$ 
>
> * 为什么把最左侧位的权重解释为 $-8$ 可以做到呢？**其实就是进行了 $-16$ 的操作，反向转了一圈**。$14-16=-2$

> 遇到一个有趣的题目：对于一个补码表示的系统，表达式`~x`的值是多少？
>
> 写出三个函数（数字到二进制补码，反码操作，二进制到数字），对分段函数分类讨论，容易得到，`~x` = $-1-x$
>
> 

#### 符号加绝对值（原码）表示的加减法

一共有四种不同的符号组合，需要考虑8种不同的情况

* 第一步，检查运算，统一为加法
* 第二步，用异或检查两数的符号一致性
* 第三步：若符号相同，绝对值相加；若符号不同，绝对值相减（减法原理同上，转换为补码加法），符号是绝对值较大的符号
  * 此处需要考虑上溢：如果 $A\geq B$ 则有上溢（模运算后舍弃）
  * 如果 $A < B$ 则无上溢，结果是一个负数，应当取其二进制补码（可以这样理解：绝对值部分使用了补码式的减法运算，结果仍然是补码表示。现在取补码就是转换为无符号整数模式，结合先前确定的符号位，就变回符号加绝对值表示）

> 值得注意的是，在该加减法中，符号位和绝对值分开计算。绝对值之间的减法运算仍然与补码相同。比如：17-22，
>
> $ 0010001-0010110 = 0010001 + 1101010 = 1111011$，所得结果是补码表示，需要再进行一次补码以还原为无符号整数表示。

#### 实数的加减法

将实数的加减法简化为*小数点对齐后以符号加绝对值格式存储的两整数的加法和减法*

* 统一为加法
* 去规范化
* 使指数相等
* 相加，处理上溢
* 规范化
* 四舍五入，停止

## Ch.5 计算机组成

关键词：中央处理单元，主存，输入输出子系统

### CPU

三部分：ALU，控制单元[Program Counter, Instruction Register]，←寄存器（registers）

* 他们各自的作用是什么？

### 主存

* 地址是什么？
* 字 word
* 字节 byte
* 地址空间：64kb，1b字长的主存有多少地址空间？（65535）

> 值得注意的地方：此处的64kb实际上指的是64*1024byte。以下是近似数对照表
>
> | 单位     | 确切的字节数        | 近似     |
> | -------- | ------------------- | -------- |
> | KB       | $2^{10}$ 1024       | $10^3$   |
> | megabyte | $2^{20}$ 1048576    | $10^6$   |
> | gigabyte | $2^{30}$ 1073741824 | $10^{9}$ |

* 一个有N字的主存需要多长的位模式来存储地址？
* 简述RAM（SRAM，DRAM）和ROM

> 补充：逻辑电路标识
>
> ![image-20220911100104995](image-20220911100104995.png)
>
> 简述非门、与非门、或非门的电路实现：需要用几个电控开关？
>
> 再次思考：异或如何使用与门或门模拟？
>
> 我的解决方案：$x XOR y = (x OR y) AND (NOT(xANDy))$这是观察与门或门真值表后，思考如何对这两个结果进行运算得出的
>
> $xORy=((NOTx)ANDy)OR(xAND(NOTy))$这是思考异或的特性：反转其中任意一个，两者就一样，可以利用与门判断

> 补充：布尔代数部分-《离散数学及其应用》
>
> * 布尔代数与命题逻辑的转换：补-否定、布尔和-析取、布尔积-合取
> * 布尔函数，布尔变元，函数的运算
> * 思考：有多少个不同的n元布尔函数？
>
> ### 吸收律：
>
> * 《计算机科学导论》表述： $ x \cdot(x^\prime+y) = x \cdot y$ 证明：分配律得 $(x \cdot x^\prime)+(x\cdot y)$ 左侧是0，消去
> * 《离散数学及其应用》表述： $x+xy=x;x(x+y)=x$ 通过真值表可以理解：布尔和强调了x的作用，布尔积削弱了y的作用
>
> ### 真值表与到表达式的互化、函数化简
>
> 和之积法与积之和法，互补项合并原理，运算完备性证明

### 子系统协作

* 三条总线：数据、地址、命令
* IO设备的接入：控制器
